<?php
/*
 * This file handles the endpoint that communicates with the dashboard.
 *
 * Upon a request, it will try to login the user, either using the participant id and birthdate of the user, or a
 * token (that was generated before). If the login is successful, it retrieves the personal links to the various
 * instruments (called here forms or surveys), compute the progression of the user in all the forms, and generates
 * a unique token that can be used for further requests.
 *
 * One assumption in the code, is that the record_id in both projects match each other (so a participant with
 * record_id=42 in the participant project, will correspond to the record id 42 in the form project).
 *
 * Failed login has different possible *reason* for it:
 * - 0: The user has a valid token, but has not logged in for MAX_TIME_LOGIN_SAVED.
 *      So he has to login with regular identifiers.
 * - 1:  Server error. For example:
 *      - More than 1 user in the database corresponding to the identifiers (should never happen).
 * - 2: Invalid participant_code or birthdate.
 * - 3: Invalid token.
 */


/*
 * REDCap Instruments IDS: (concerns COMPLETED_KEYWORDS, QUESTION_KEYWORDS and INSTRUMENT_NAMES)
 */

// The field ids in the form project that tells the progression in a form (0=uncomplete, 1= unverified, 2= complete, etc.)
define('COMPLETED_KEYWORDS', ['a_complete', 'b_complete', 'c_complete', 'd_complete']);

// The id of the form, that will be the prefix of any question in the form (ex: "a" prefix => a_q39, a_q40, etc..)
define('QUESTION_KEYWORDS', ['a', 'b', 'c', 'd']);

// Use REDCap::getInstrumentNames() to know which are the instruments name (will be used to get the survey links)
define('INSTRUMENT_NAMES', ['a', 'b', 'c', 'd']);

define('FORM_COMPLETED_CODE', 2); // The value corresponding to a completed form (when retrieving REDCap completed form variable)

# REDCap participant field names (for user authentication)
define('FSO_FIELD', 'fso_code'); // The name of the fso code field in the participant project
define('PARTICIPANT_ID_FIELD', 'participant_code'); // The name of the participant code field in the participant project
define('BIRTH_FIELD', 'dob'); // The name of the birth date field in the participant project

# REDCap projects ids
define('PARTICIPANT_PROJECT_ID', 15); // The id of the REDCap participant project
define('FORM_PROJECT_ID', 16); // The id of the REDCap Forms (Swiss Health Study) project


define('MAX_TIME_LOGIN_SAVED', 1209600); // in seconds = 2 weeks = max time without any login

# Encryption
define('ENCRYPTION_METHOD', "aes-256-gcm"); // The type of encryption used
define('ENCRYPTION_TAG_LENGTH', 16); // The length of the encryption tag
define('ENCRYPTION_KEY_FILENAME', './keys/symmetric_key.pem'); // Path to a file containing a secret key corresponding to the encryption method


/**
 * Try to login with either the $participantCode + $birthDate, or using a token, by looking
 * in the participant database if a participant corresponds to the login ids.
 * If successful, returns the current progression of the user. If failed, return an error message.
 *
 * @param $participantCode string The login id provided used to verify identity of the user, can be empty if a token is used.
 * @param $birthDate string The birthdate provided used to verify identity of the user, can be empty if a token is used.
 * @param $token string A token used as alternative login id. Can be empty if the primary login ids are provided.
 * @return array An associative array (json format) that will be returned to the user. In case of a successful login,
 *  it will contain a return token, the progression of the user in the forms and the links to the forms. In case of
 * a failed login, it will contain an error code.
 * @throws Exception if the underlying random_bytes method used here was not able to gather sufficient entropy.
 */
function tryLogin($participantCode, $birthDate, $token)
{
    // Either the token, or both the regular ids must be provided
    if ($token == "" and ($participantCode == "" or $birthDate == "")) {
        return failedLogin(2);
    }

    // If token is used
    if ($participantCode == "" and $birthDate == "") {
        $user_logins = decryptToken($token);

        // If the token was altered in any way, the login has failed
        if (!$user_logins) {
            return failedLogin(3);
        }

        // The token was generated by this endpoint, so we can extract the information
        $user_logins = json_decode($user_logins, true);
        $participantCode = $user_logins["participantCode"];
        $birthDate = $user_logins["birthDate"];
        $lastLoginTime = $user_logins["loginTimeStamp"];

        // If the user has not logged in for MAX_TIME_LOGIN_SAVED, then they have to login again.
        if (time() - $lastLoginTime > MAX_TIME_LOGIN_SAVED) {
            return failedLogin(0);
        }
        // Note: It is useful to try login again with identifiers from the token in case some information has changed
    }

    // Request the redcap participant database, to look for the user
    // Note that the birthdate is a string in the format: "YYYY-MM-DD"
    $request_filter = '([' . FSO_FIELD . '] = "' . $participantCode . '" || [' . PARTICIPANT_ID_FIELD . '] = "' . $participantCode . '") && [' . BIRTH_FIELD . '] = "' . $birthDate . '"';
    $request_params = array(
        'project_id' => PARTICIPANT_PROJECT_ID,
        'return_format' => 'array',
        'filterLogic' => $request_filter,
    );
    $user = REDCap::getData($request_params);

    if (count($user) > 1) {
        return failedLogin(1);
    } else if (count($user) == 0) { // Incorrect login ids (does not exist in DB)
        return failedLogin(2);
    } else { // count($user) == 1
        $record_id = array_keys($user)[0];
        try{
            return successfulLogin($participantCode, $birthDate, $record_id);
        }
        catch(Exception $e) {
            return failedLogin(1);
        }
    }
}


/**
 * Executes when the login is successful, returns a connexion token, as well as the current progression of the
 * user as well as the links for the forms.
 *
 * @param $participantCode string The participant code used for identify a user.
 * @param $birthDate string The birthdate of a user used for identification.
 * @param $user_record_id integer The redcap record id of the user, used as unique identification mean.
 * @return array An associative array (json format) that will be returned to the user in case of a successful login,
 *  which will contain a return token, the progression of the user in the forms and the links to the forms.
 * @throws Exception if the underlying random_bytes method used here was not able to gather sufficient entropy.
 */
function successfulLogin($participantCode, $birthDate, $user_record_id)
{
    $token = generateToken($participantCode, $birthDate);
    $formLinks = getFormLinks($user_record_id);
    $progression = getProgression($user_record_id);
    return [
        'ok' => true,
        'token' => $token,
        'progression' => $progression,
        'formLinks' => $formLinks,
    ];
}

/**
 * Generates the json response to a user, in case of a failed login.
 *
 * @param $reason integer An error code to explain why the login did not happen
 * @return array An associative array (json format) that will be returned to the user in case of a failed login.
 */
function failedLogin($reason)
{
    return ['ok' => false, 'reason' => $reason];
}


/**
 * Generates a new token which consist in the login information, as well as the current timestamp. They are encrypted
 * to keep the information secured as well as preserving the authenticity of the token.
 *
 * @param $participantCode string The participant code used for identifying a user.
 * @param $birthDate string The birthdate of a user.
 * @return string The generated token.
 * @throws Exception if the underlying random_bytes method used here was not able to gather sufficient entropy.
 */
function generateToken($participantCode, $birthDate)
{
    $token_to_encrypt = [
        'participantCode' => $participantCode,
        'birthDate' => $birthDate,
        'loginTimeStamp' => time()];
    $token_to_encrypt = json_encode($token_to_encrypt);
    return encryptToken($token_to_encrypt);
}


/**
 * Generate the form links for a specific user (record id)
 *
 * @param $record_id string The record id of the user on which to get the links from.
 *
 * @return array array[string] A list of the survey links, in the same order as the variable INSTRUMENT_NAMES.
 */
function getFormLinks($record_id)
{
    $links = [];
    foreach (INSTRUMENT_NAMES as $instrument) {
        array_push($links, REDCap::getSurveyLink($record_id, $instrument));
    }
    return $links;
}


/**
 * Give the progression of the participant in the different forms.
 *
 * @param $record_id string The record id of the user on which to get the progression.
 *
 * @return array array[float] An array of number between 0 and 1, showing the progression in the different surveys
 *  forms (0 = not started, 1 = finished). Each progression value correspond to the position keyword found in
 *  the COMPLETED_KEYWORDS or QUESTION_KEYWORDS arrays.
 *
 */
function getProgression($record_id)
{
    /*
     * Note: some optimizations could be done, for example knowing once the total number of questions in each form
     * could avoid recomputing it at each request. However, this code is robust to any changes that might be done
     * to the questions. The only thing that might need an update after changes in the question are the
     * lists QUESTION_KEYWORDS and COMPLETED_KEYWORDS.
     */

    // Creates table for lookup in ~O(1)
    $form_completed_code = []; // completed keyword in project => redcap completion code (ex: a_complete => 0, b_complete => 2)
    $question_progression = []; // question id => count of the questions that were answered by the user (ex: b => 31)
    $question_total = []; // question id => total number of question in this specific form (ex: b => 50)

    foreach (COMPLETED_KEYWORDS as $kw) {
        $form_completed_code[$kw] = -1;
    }

    foreach (QUESTION_KEYWORDS as $kw) {
        $question_progression[$kw] = 0;
        $question_total[$kw] = 0;
    }

    // Request the info about the forms, about the given record id
    $params = array(
        'project_id' => FORM_PROJECT_ID,
        'return_format' => 'array',
        'filterLogic' => '[record_id] = "' . $record_id . '"',
    );
    $formData = REDCap::getData($params);
    if (count($formData) != 1) {
        // TODO: send message to admin maybe? Return an error response to user?
        throw new Exception('Number of users found with record id "' . $record_id . '" in the table must be 1 (found ' . count($formData) . ').');
    }

    // The received array is in the format: [$record_id => [$unique_value => [$field_name => $field_value]]
    // So only the inside array (2 levels from the "surface") must be examined
    $key1 = array_keys($formData)[0];
    $key2 = array_keys($formData[$key1])[0];

    // Go through each question / answer pair of a user for all forms
    foreach ($formData[$key1][$key2] as $field_name => $field_value) {

        // If the field is a completed form info, save completion code. Ex: a_complete => "2"
        if (array_key_exists($field_name, $form_completed_code)) {
            $form_completed_code[$field_name] = intval($field_value);

            // Find which form it belonged to, and find if it has been answered by the user
        } else {
            // Select the question id (assuming that the format is: questionId_somethingElse. Ex: a_q20_q3)
            $question_id = explode('_', $field_name, 2)[0];
            if (array_key_exists($question_id, $question_progression)) { // keys are same in $question_progression and $question_total
                $question_total[$question_id]++;

                // Multiple choice question (ex: [1=>"0", 2->"1", 3->"1", 4->"0"])
                if (is_array($field_value) or ($field_value instanceof Traversable)) {
                    // If any answer != 0, then user has done it (if not completed, all answers are of value "0")
                    $userHasResponded = false;
                    foreach ($field_value as $answer_name => $answer_value) {
                        if ($answer_value != "0") {
                            $userHasResponded = true;
                        }
                    }
                    if ($userHasResponded) {
                        $question_progression[$question_id]++;
                    }
                } else { // single choice question (by default is an empty string, ex: d_q3 => "")
                    if ($field_value != "") {
                        $question_progression[$question_id]++;
                    }
                }
            } else {
                // In the future, add a list of exception (ex: record_id: "101") and send a message to admin if there
                // is any other keyword not detected, so to detect future bugs early on.
            }
        }

    }

    // Compute the progression values
    $progression = [];

    for ($i = 0; $i < count(QUESTION_KEYWORDS); $i++) {
        $qkw = QUESTION_KEYWORDS[$i];
        $ckw = COMPLETED_KEYWORDS[$i];

        // If there is a completion code, it "wins" against the progression computation
        if ($form_completed_code[$ckw] == FORM_COMPLETED_CODE) {
            $progression[$i] = 1.0;
        } else {
            // Compute the progression by dividing the nb of question answered / total number of question
            if ($question_total[$qkw] == 0) { // dividing by zero
                $progression[$i] = 0.0;
            } else {
                $progression[$i] = round($question_progression[$qkw] / $question_total[$qkw], 3);
            }
        }
    }
    return $progression;
}


/**
 * Encrypt a message with an AES symmetric encryption system, using the key file at location ENCRYPTION_KEY_FILENAME.
 *
 * @param $text string The plain text to encrypt.
 * @return string The encrypted text (the plain text that was encoded with the symmetric key).
 * @throws Exception if the random_bytes method was not able to gather sufficient entropy.
 */
function encryptToken($text)
{
    $key = file_get_contents(ENCRYPTION_KEY_FILENAME); // Get AES key

    $iv_length = openssl_cipher_iv_length(ENCRYPTION_METHOD);
    $iv = random_bytes($iv_length);
    $encrypted_text = openssl_encrypt($text, ENCRYPTION_METHOD, $key, $options = 0, $iv, $tag);
    $encrypted_message = $iv . $tag . $encrypted_text;

    $encrypted_message = bin2hex($encrypted_message);

    return $encrypted_message;
}

/**
 * Decrypt a message with an AES symmetric encryption system, using the key file at location ENCRYPTION_KEY_FILENAME.
 *
 * @param $encrypted_message string The encoded message to decrypt.
 * @return string The decrypted message.
 */
function decryptToken($encrypted_message)
{
    $encrypted_message = hex2bin($encrypted_message);


    $loaded_key = file_get_contents(ENCRYPTION_KEY_FILENAME); // Get AES key
    $iv_length = openssl_cipher_iv_length(ENCRYPTION_METHOD);
    $loaded_iv = substr($encrypted_message, 0, $iv_length);
    $loaded_tag = substr($encrypted_message, $iv_length, ENCRYPTION_TAG_LENGTH);
    $loaded_encrypted_text = substr($encrypted_message, $iv_length + ENCRYPTION_TAG_LENGTH);

    $decrypted_text = openssl_decrypt($loaded_encrypted_text, ENCRYPTION_METHOD, $loaded_key, $options = 0, $loaded_iv, $loaded_tag);
    return $decrypted_text;
}

/**
 * Check that the participant code can be used in a query to the redcap database.
 *
 * @param $s the string to check
 * @return bool True if the participant code is alpha-numeric
 */
function participantCodeIsValid($s)
{
    return strlen($s) < 20 && ctype_alnum($s);
}

/**
 * Check that the birthdate can be used in a query to the redcap database.
 *
 * @param $s the string to check
 * @return bool True if the birthdate is valid (expected format "1111-22-33")
 */
function birthDateIsValid($s)
{
    // expected format "1111-22-33"
    return strlen($s) == 10 && ctype_digit(substr($s, 0, 4)) && ctype_digit(substr($s, 5, 2))
        && ctype_digit(substr($s, 8, 2)) && $s[4] == '-' && $s[7] == '-';
}


// -------------------- RESPONSE -------------------- \\


// Add artificially the correct project id to the request, for survey link request to work (must be before require redcap_connect.php)
$_GET['pid'] = FORM_PROJECT_ID;

// Disable REDCap's authentication
define("NOAUTH", true);

// Call the REDCap Connect file in the main "redcap" directory
require_once "../../../redcap_connect.php";

// Takes a json file in the request, try to login with it and return a json with the output to the user
if ($_SERVER["REQUEST_METHOD"] == "POST") {
    $data = json_decode(file_get_contents('php://input'), true);

    $participantCode = $data["participantCode"];
    if (!participantCodeIsValid($participantCode)) {
        $participantCode = "";
    }
    $birthDate = $data["birthDate"];
    if (!birthDateIsValid($birthDate)) {
        $birthDate = "";
    }
    $token = $data["token"];

    $output = tryLogin($participantCode, $birthDate, $token);

    header('Content-type: application/json');
    echo json_encode($output);
}

?>